from azure.iot.device import IoTHubDeviceClient
import can
import time
import csv
import os

def send_can_message(bus, can_id, data):
    message = can.Message(arbitration_id=can_id, data=data)
    bus.send(message)

def convert_telemetry_to_candump(transmission_data):
    can_id = transmission_data.get("can_id", 1001)  # Default CAN ID
    can_data = []

    for key, value in transmission_data.items():
        if key == "can_id":
            continue  # Skip the "can_id" key

        if isinstance(value, int):
            byte_value = value % 256
        elif isinstance(value, float):
            byte_value = int(value) % 256
        elif isinstance(value, str):
            try:
                byte_value = int(value) % 256
            except ValueError:
                try:
                    byte_value = int(float(value)) % 256
                except ValueError:
                    continue  # Skip this key-value pair if conversion is not possible
        else:
            continue  # Skip unsupported data types

        can_data.append(byte_value)

    return can_id, can_data

def receive_can_message(bus):
    message = bus.recv()
    return message

class CanController:
    def __init__(self, bus):
        self.last_messages = {}
        self.bus = bus

    def send_can_message(self, can_id, can_data):
        message_key = f"{can_id}_{can_data}"
        if message_key not in self.last_messages:
            self.last_messages[message_key] = True
            send_can_message(self.bus, can_id, can_data)

def handle_device_twin_update(twin, can_controller, csv_file):
    transmission_data = twin.get("reported", {}).get("transmission_data")
    if transmission_data and isinstance(transmission_data, dict):
        can_id, can_data = convert_telemetry_to_candump(transmission_data)
        if can_data:
            can_controller.send_can_message(can_id, can_data)
            write_to_csv(csv_file, can_id, can_data)

def write_to_csv(csv_file, can_id, can_data):
    file_exists = os.path.isfile(csv_file)
    with open(csv_file, 'a', newline='') as file:
        writer = csv.writer(file)
        if not file_exists:
            writer.writerow(["can_id"] + [f"byte_{i}" for i in range(len(can_data))])
        writer.writerow([can_id] + can_data)

def main(csv_file):
    bus = can.interface.Bus(channel='vcan0', bustype='socketcan')

    device_connection_string = "HostName=EDGTneerTrainingPractice.azure-devices.net;DeviceId=nodered;SharedAccessKey=mOeGufRBpvjmFut51ghJ0gjmWZDR8BHN1WWJtdsrBY4="
    client = IoTHubDeviceClient.create_from_connection_string(device_connection_string)

    retry_counter = 0
    while True:
        try:
            client.connect()
            can_controller = CanController(bus)
            print("Started listening for Device Twin updates...")
            while True:
                twin = client.get_twin()
                handle_device_twin_update(twin, can_controller, csv_file)
                can_message = receive_can_message(bus)
                if can_message:
                    can_id = can_message.arbitration_id
                    can_data = ' '.join(format(byte, '02X') for byte in can_message.data)
                    print(f"Received CAN message: Timestamp: {can_message.timestamp}    ID: {can_id:08X}    Data: {can_data}    Channel: {can_message.channel_info}")
                    write_to_csv(csv_file, can_id, can_message.data)  # Write received CAN message to CSV
        except Exception as e:
            print("Exception caught:", str(e))
            if retry_counter < 3:
                retry_counter += 1
                print("Retrying in 10 seconds...")
                time.sleep(10)
                continue
            else:
                print("Maximum retry attempts reached. Exiting...")
                break

    client.disconnect()
    print("Stopped listening for Device Twin updates.")

if __name__ == '__main__':
    csv_file = "can_data.csv"
    print("Starting CAN Data Logger...")
    main(csv_file)
