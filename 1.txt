import minimalmodbus
import paho.mqtt.client as mqtt
import time
import random

# Modbus RTU Configuration
modbus_port = 'COM2'  # Replace with the appropriate serial port for Modbus RTU
modbus_slave_address = 1  # Replace with the Modbus slave device address
modbus_register_address = 0  # Replace with the starting register address
modbus_register_count = 2  # Replace with the number of registers to read

# MQTT Configuration
mqtt_broker = 'your_mqtt_broker_address'
mqtt_topic = 'your_mqtt_topic'

# Variable to store previous data
previous_data = None
data_lock = threading.Lock()

def read_modbus_data():
    instrument = minimalmodbus.Instrument(modbus_port, modbus_slave_address)
    instrument.serial.baudrate = 9600  # Set the baud rate to match your Modbus setup
    instrument.serial.timeout = 0.2  # Set the timeout as required
    data = instrument.read_registers(modbus_register_address, modbus_register_count)
    return data

def write_modbus_data_to_diagslave():
    instrument = minimalmodbus.Instrument(modbus_port, modbus_slave_address)
    instrument.serial.baudrate = 9600  # Set the baud rate to match your Modbus setup
    instrument.serial.timeout = 0.2  # Set the timeout as required

    # Generate random data for a range of registers
    random_data = [random.randint(0, 100) for _ in range(num_registers_diagslave)]

    # Print the random data before writing to Modbus
    print(f"Writing random data {random_data} to Modbus registers {start_register_address_diagslave} to {start_register_address_diagslave + num_registers_diagslave - 1}")

    # Write random data to the consecutive Modbus registers in `diagslave`
    instrument.write_registers(start_register_address_diagslave, random_data)

def on_connect(client, userdata, flags, rc):
    print("Connected to MQTT Broker with result code " + str(rc))

def main():
    global previous_data

    # MQTT Setup
    mqtt_client = mqtt.Client()
    mqtt_client.on_connect = on_connect
    mqtt_client.connect(mqtt_broker, 1883, 60)
    mqtt_client.loop_start()

    try:
        while True:
            # Modbus RTU Communication - Read data
            data = read_modbus_data()

            # Check if the data has changed
            if data != previous_data:
                print("New data:", data)

                # Publish data to MQTT broker
                mqtt_client.publish(mqtt_topic, str(data))

                # Update previous_data with the new data
                with data_lock:
                    previous_data = data

            # Insert random data to `diagslave`
            write_modbus_data_to_diagslave()

            # Adjust the polling rate as needed
            time.sleep(1)

    except KeyboardInterrupt:
        mqtt_client.loop_stop()
        mqtt_client.disconnect()

if __name__ == "__main__":
    main()
