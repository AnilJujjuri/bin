from azure.iot.device import IoTHubDeviceClient
import can
import time

def send_can_message(bus, can_id, data):
    message = can.Message(arbitration_id=can_id, data=data)
    bus.send(message)

def convert_telemetry_to_candump(telemetry_data):
    candump = ""
    can_data = []

    for key, value in telemetry_data.items():
        if isinstance(value, int):
            byte_value = value % 256
        elif isinstance(value, float):
            byte_value = int(value) % 256
        elif isinstance(value, str):
            try:
                byte_value = int(value) % 256
            except ValueError:
                try:
                    byte_value = int(float(value)) % 256
                except ValueError:
                    continue  # Skip this key-value pair if conversion is not possible
        else:
            continue  # Skip unsupported data types

        can_data.append(byte_value)
        candump += f"{key}_{byte_value}_"

    return candump.rstrip("_"), can_data

class CanController:
    def __init__(self, bus):
        self.last_messages = {}
        self.bus = bus

    def send_can_message(self, can_id, can_data):
        message_key = f"{can_id}_{can_data}"
        if message_key not in self.last_messages:
            self.last_messages[message_key] = True
            send_can_message(self.bus, can_id, can_data)

def handle_device_twin_update(twin, can_controller):
    reported_properties = twin.get("reported", {})
    can_device_id = twin.get("can_device_id", "")

    if not reported_properties:  # Skip if reported properties is empty
        return

    # Assign default can_id if can_device_id is not provided or is an empty string
    # if not can_device_id:
    #     can_id = 1001
    # else:
    #     try:
    #         can_id = int(can_device_id)
    #     except ValueError:
    #         print("Invalid value for can_device_id:", can_device_id)
    #         return

    for can_device_id, telemetry_data in reported_properties.items():
        if isinstance(telemetry_data, dict):
            candump, can_data = convert_telemetry_to_candump(telemetry_data)
            if candump is not None and can_data is not None:
                can_id = int(can_device_id) if can_device_id.isdigit() else 1001
                can_controller.send_can_message(can_id, can_data)

def main():
    bus = can.interface.Bus(channel='vcan0', bustype='socketcan')

    device_connection_string = "HostName=EDGTneerTrainingPractice.azure-devices.net;DeviceId=nodered;SharedAccessKey=mOeGufRBpvjmFut51ghJ0gjmWZDR8BHN1WWJtdsrBY4="
    client = IoTHubDeviceClient.create_from_connection_string(device_connection_string)

    client.connect()
    retry_counter = 0
    can_controller = CanController(bus)
    while True:
        try:
            twin = client.get_twin()
            handle_device_twin_update(twin, can_controller)
            # Retry mechanism
            if retry_counter < 3:
                time.sleep(20)  # Wait for 20 seconds between retries
                retry_counter += 1
            else:
                break  # Disconnect after the maximum number of retries
        except Exception as e:
            print("Exception caught:", str(e))
            continue

    client.disconnect()

if __name__ == '__main__':
    main()
from azure.iot.device import IoTHubDeviceClient
import can
import time

def send_can_message(bus, can_id, data):
    message = can.Message(arbitration_id=can_id, data=data)
    bus.send(message)

def convert_telemetry_to_candump(telemetry_data):
    candump = ""
    can_data = []

    for key, value in telemetry_data.items():
        if isinstance(value, int):
            byte_value = value % 256
        elif isinstance(value, float):
            byte_value = int(value) % 256
        elif isinstance(value, str):
            try:
                byte_value = int(value) % 256
            except ValueError:
                try:
                    byte_value = int(float(value)) % 256
                except ValueError:
                    continue  # Skip this key-value pair if conversion is not possible
        else:
            continue  # Skip unsupported data types

        can_data.append(byte_value)
        candump += f"{key}_{byte_value}_"

    return candump.rstrip("_"), can_data

class CanController:
    def __init__(self, bus):
        self.last_messages = {}
        self.bus = bus

    def send_can_message(self, can_id, can_data):
        message_key = f"{can_id}_{can_data}"
        if message_key not in self.last_messages:
            self.last_messages[message_key] = True
            send_can_message(self.bus, can_id, can_data)

def handle_device_twin_update(twin, can_controller):
    reported_properties = twin.get("reported", {})
    can_device_id = twin.get("can_device_id", "")

    if not reported_properties:  # Skip if reported properties is empty
        return

    # # Assign default can_id if can_device_id is not provided or is an empty string
    # if not can_device_id:
    #     can_id = 1001
    # else:
    #     try:
    #         can_id = int(can_device_id)
    #     except ValueError:
    #         print("Invalid value for can_device_id:", can_device_id)
    #         return

    for can_device_id, telemetry_data in reported_properties.items():
        if isinstance(telemetry_data, dict):
            candump, can_data = convert_telemetry_to_candump(telemetry_data)
            if candump is not None and can_data is not None:
                can_id = int(can_device_id) if can_device_id.isdigit()else 1001
                can_controller.send_can_message(can_id, can_data)

def main():
    bus = can.interface.Bus(channel='vcan0', bustype='socketcan')

    device_connection_string = "HostName=EDGTneerTrainingPractice.azure-devices.net;DeviceId=nodered;SharedAccessKey=mOeGufRBpvjmFut51ghJ0gjmWZDR8BHN1WWJtdsrBY4="
    client = IoTHubDeviceClient.create_from_connection_string(device_connection_string)

    client.connect()
    retry_counter = 0
    can_controller = CanController(bus)
    while True:
        try:
            twin = client.get_twin()
            handle_device_twin_update(twin, can_controller)
            # Retry mechanism
            if retry_counter < 3:
                time.sleep(20)  # Wait for 20 seconds between retries
                retry_counter += 1
            else:
                break  # Disconnect after the maximum number of retries
        except Exception as e:
            print("Exception caught:", str(e))
            continue

    client.disconnect()

if __name__ == '__main__':
    main()
