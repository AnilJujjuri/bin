import time
import json
import asyncio
import minimalmodbus

# Define the Modbus RTU device configuration
modbus_rtu_config = {
    'devices': {
        "1001": {
            'id': '1001',
            'type': 'modbus-rtu',  # Change to 'modbus-rtu' for Modbus RTU devices
            'thingId': '2001',
            'interval': 10000,
            'connection': {
                'port': '/dev/ttyUSB0',  # Change to your actual serial port
            },
            'signals': {
                "temperature": {
                    'name': "temperature",
                    'address': '1',  # Replace with your actual Modbus address
                    'length': 1,
                },
                # Add more signals if needed
            }
        }
    }
}

def get_address(address, length):
    fc = address[0]
    temp = address[1:]
    response = ''
    if fc == '1':
        response = 'c' + temp
    elif fc == '2':
        response = 'i' + temp
    elif fc == '3':
        response = 'hr' + temp
    elif fc == '4':
        response = 'ir' + temp
    return response + '-' + str(int(temp) + int(length)) if int(length) > 1 else response

async def collect():
    twin = await get_connection()
    while True:
        try:
            print("Running")
            connection = twin['devices']
            if connection:
                for key, element in connection.items():
                    telemetry = {
                        "thingId": element['thingId'],
                        "deviceId": element['id'],
                        "message_type": "telemetry",
                        "data": {}
                    }
                    try:
                        # Connect to Modbus RTU device
                        instrument = minimalmodbus.Instrument(element['connection']['port'], int(element['id']))
                        instrument.serial.baudrate = 9600
                        instrument.serial.bytesize = 8
                        instrument.serial.parity = minimalmodbus.serial.PARITY_NONE
                        instrument.serial.stopbits = 1

                        for signal_key, signal in element['signals'].items():
                            print(signal['name'])
                            address = int(signal['address']) - 1  # Modbus addresses are 0-based
                            value = instrument.read_register(address, functioncode=3, numberOfDecimals=0)
                            print(value)
                            telemetry['data'][signal['name']] = value

                        telemetry['ts'] = str(int(time.time()))
                        print(telemetry)

                        # Rest of the code remains unchanged

                    except Exception as e:
                        print("An error has occurred:", e)

                    await timeout(element['interval'])

        except Exception as e:
            print("Error in communication/processing:", e)

        await timeout(5000)

async def timeout(ms):
    await asyncio.sleep(ms / 1000)

# Set up Modbus RTU configuration
twin = None

async def set_connection(twin_obj):
    global twin
    twin = twin_obj
    if twin is None:
        twin = twin_obj
        await asyncio.sleep(1)
        print('Starting Data Acquisition Task')
        await collect()
    else:
        twin = twin_obj
    print("Updated twin")
    print(twin_obj)
    print(twin)

async def get_connection():
    return twin

# Start data collection
loop = asyncio.get_event_loop()
loop.run_until_complete(set_connection(modbus_rtu_config))

# Mock the Message class, replace this with actual implementation
class Message:
    def __init__(self, payload):
        self.payload = payload
